# -*- coding: utf-8 -*-
"""Copy of flight_price_project_main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1soCdDH4YNTBZbK96GnDAblJUyrV9XiMd

# Flight Price Prediction
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()



train_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Data_Train.xlsx")
train_data

pd.set_option('display.max_columns', None)

train_data.head()

train_data.shape

train_data.info()

train_data["Duration"].value_counts()

train_data.dropna(inplace = True)

train_data.isnull().sum()

"""---

#EDA
"""

train_data["Journey_day"] = pd.to_datetime(train_data.Date_of_Journey, format="%d/%m/%Y").dt.day

train_data["Journey_month"] = pd.to_datetime(train_data["Date_of_Journey"], format = "%d/%m/%Y").dt.month

train_data.head()

# Since we have converted Date_of_Journey column into integers, Now we can drop as it is of no use.
train_data.drop(["Date_of_Journey"], axis = 1, inplace = True)

# Departure time is when a plane leaves the gate.
# Similar to Date_of_Journey we can extract values from Dep_Time

# Extracting Hours
train_data["Dep_hour"] = pd.to_datetime(train_data["Dep_Time"]).dt.hour

# Extracting Minutes
train_data["Dep_min"] = pd.to_datetime(train_data["Dep_Time"]).dt.minute

# Now we can drop Dep_Time as it is of no use
train_data.drop(["Dep_Time"], axis = 1, inplace = True)

train_data.head()

# Arrival time is when the plane pulls up to the gate.
# Similar to Date_of_Journey we can extract values from Arrival_Time

# Extracting Hours
train_data["Arrival_hour"] = pd.to_datetime(train_data.Arrival_Time).dt.hour

# Extracting Minutes
train_data["Arrival_min"] = pd.to_datetime(train_data.Arrival_Time).dt.minute

# Now we can drop Arrival_Time as it is of no use
train_data.drop(["Arrival_Time"], axis = 1, inplace = True)

train_data.head()

# Time taken by plane to reach destination is called Duration
# It is the differnce betwwen Departure Time and Arrival time

# Assigning and converting Duration column into list
duration = list(train_data["Duration"])

for i in range(len(duration)):
    if len(duration[i].split()) != 2:    # Check if duration contains only hour or mins
        if "h" in duration[i]:
            duration[i] = duration[i].strip() + " 0m"   # Adds 0 minute
        else:
            duration[i] = "0h " + duration[i]           # Adds 0 hour

duration_hours = []
duration_mins = []
for i in range(len(duration)):
    duration_hours.append(int(duration[i].split(sep = "h")[0]))    # Extract hours from duration
    duration_mins.append(int(duration[i].split(sep = "m")[0].split()[-1]))   # Extracts only minutes from duration

# Adding duration_hours and duration_mins list to train_data dataframe

train_data["Duration_hours"] = duration_hours
train_data["Duration_mins"] = duration_mins

train_data.drop(["Duration"], axis = 1, inplace = True)

train_data.head()

"""---

# Handling Categorical Data
"""

train_data["Airline"].value_counts()

train_data["Source"].value_counts()

train_data["Destination"].value_counts()

train_data["Route"].value_counts()

import matplotlib.pyplot as plt
import numpy as np

# Assuming you have a pandas DataFrame named 'df' with columns 'A', 'B', and 'C'

# Bar plot
plt.figure(figsize=(10, 5))
train_data['Airline'].value_counts().plot(kind='bar')
plt.title('Bar Plot of Airline')
plt.show()
print("===========================================================================================================\n\n")

# Pie chart
plt.figure(figsize=(6, 6))
train_data['Airline'].value_counts().plot(kind='pie', autopct='%1.1f%%')
plt.title('Pie Chart of Airline')
plt.show()
print("===========================================================================================================\n\n")

# From graph we can see that Jet Airways Business have the highest Price.
# Apart from the first Airline almost all are having similar median
# Airline vs Price
sns.catplot(y = "Price", x = "Airline", data = train_data.sort_values("Price", ascending = False), kind="boxen", height = 6, aspect = 3)
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have a DataFrame named 'train_data' with columns 'Airline' and 'Price'

# Calculate the Interquartile Range (IQR)
Q1 = train_data['Price'].quantile(0.25)
Q3 = train_data['Price'].quantile(0.75)
IQR = Q3 - Q1

# Define the lower and upper bounds to filter outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter the data to remove outliers
filtered_data = train_data[(train_data['Price'] >= lower_bound) & (train_data['Price'] <= upper_bound)]

# Plot the boxen plot without outliers
plt.figure(figsize=(12, 8))
sns.boxenplot(y="Price", x="Airline", data=filtered_data.sort_values("Price", ascending=False), color='skyblue', width=0.8)

# Customize the plot appearance
plt.title('Airline vs Price (Outliers Removed)')
plt.xticks(rotation=45)
plt.ylabel('Price')
plt.xlabel('Airline')
plt.grid(True)

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have a DataFrame named 'train_data' with columns 'Airline' and 'Price'

# Calculate the Interquartile Range (IQR)
Q1 = train_data['Price'].quantile(0.25)
Q3 = train_data['Price'].quantile(0.75)
IQR = Q3 - Q1

# Define the lower and upper bounds to identify outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter the data to get outliers
outliers_data = train_data[(train_data['Price'] < lower_bound) | (train_data['Price'] > upper_bound)]

# Plot outliers using a box plot
plt.figure(figsize=(10, 6))
sns.boxplot(y="Price", data=outliers_data, color='skyblue')
plt.title('Outliers in Price')
plt.ylabel('Price')
plt.grid(True)
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have a DataFrame named 'train_data' with columns 'Price'

# Calculate the Interquartile Range (IQR)
Q1 = train_data['Price'].quantile(0.25)
Q3 = train_data['Price'].quantile(0.75)
IQR = Q3 - Q1

# Define the lower and upper bounds to identify outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter the data to remove outliers
train_data_no_outliers = train_data[(train_data['Price'] >= lower_bound) & (train_data['Price'] <= upper_bound)]

# Check the shape to see how many outliers were removed
print("Original shape:", train_data.shape)
print("Shape after removing outliers:", train_data_no_outliers.shape)

# Plot boxplot of outliers
plt.figure(figsize=(10, 6))
sns.boxplot(y="Price", data=train_data_no_outliers, color='skyblue')
plt.title('Boxplot of Price without Outliers')
plt.ylabel('Price')
plt.grid(True)
plt.show()

# Optionally, if you want to overwrite the original DataFrame with the one without outliers
# train_data = train_data_no_outliers

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have a DataFrame named 'train_data' with columns 'Airline' and 'Price'

# Customize the boxen plot
plt.figure(figsize=(12, 8))
sns.boxenplot(y="Price", x="Airline", data=train_data.sort_values("Price", ascending=False), color='skyblue', width=0.8)

# Highlight outliers
sns.swarmplot(y="Price", x="Airline", data=train_data, color='red', size=5)  # Mark outliers with red dots

# Customize the plot appearance
plt.title('Airline vs Price (with Outliers Highlighted)')
plt.xticks(rotation=45)
plt.ylabel('Price')
plt.xlabel('Airline')
plt.ylim(0, train_data['Price'].quantile(0.99))  # Set y-axis limits to zoom in on the data (adjust as needed)
plt.grid(True)

plt.tight_layout()
plt.show()

# As Airline is Nominal Categorical data we will perform OneHotEncoding

Airline = train_data[["Airline"]]

Airline = pd.get_dummies(Airline, drop_first= True)

Airline.head()

train_data["Source"].value_counts()

import matplotlib.pyplot as plt
import numpy as np

# Assuming you have a pandas DataFrame named 'df' with columns 'A', 'B', and 'C'

# Bar plot
plt.figure(figsize=(10, 5))
train_data['Source'].value_counts().plot(kind='bar', color='#66b3ff')
plt.title('Bar Plot of Source')
plt.show()
print("===========================================================================================================\n\n")

# Pie chart
plt.figure(figsize=(6, 6))
train_data['Source'].value_counts().plot(kind='pie', autopct='%1.1f%%')
plt.title('Pie Chart of Source')
plt.show()
print("===========================================================================================================\n\n")

# Source vs Price

sns.catplot(y = "Price", x = "Source", data = train_data.sort_values("Price", ascending = False), kind="boxen", height = 4, aspect = 3)
plt.show()

# As Source is Nominal Categorical data we will perform OneHotEncoding

Source = train_data[["Source"]]

Source = pd.get_dummies(Source, drop_first= True)

Source.head()

train_data["Destination"].value_counts()

import matplotlib.pyplot as plt
import numpy as np

# Assuming you have a pandas DataFrame named 'df' with columns 'A', 'B', and 'C'

# Bar plot
plt.figure(figsize=(10, 5))
#colors = ['#ff9999', '#66b3ff', '#99ff99', '#ffcc99', '#cc99ff']  # specify your desired colors here
train_data['Destination'].value_counts().plot(kind='bar', color='#ff9999')
plt.title('Bar Plot of Destination')
plt.show()
print("===========================================================================================================\n\n")

# Pie chart
plt.figure(figsize=(6, 6))
train_data['Destination'].value_counts().plot(kind='pie', autopct='%1.1f%%')
plt.title('Pie Chart of Destination')
plt.show()
print("===========================================================================================================\n\n")

# As Destination is Nominal Categorical data we will perform OneHotEncoding

Destination = train_data[["Destination"]]

Destination = pd.get_dummies(Destination, drop_first = True)

Destination.head()

train_data["Route"]

# Additional_Info contains almost 80% no_info
# Route and Total_Stops are related to each other

train_data.drop(["Route", "Additional_Info"], axis = 1, inplace = True)

train_data["Total_Stops"].value_counts()

# As this is case of Ordinal Categorical type we perform LabelEncoder
# Here Values are assigned with corresponding keys

train_data.replace({"non-stop": 0, "1 stop": 1, "2 stops": 2, "3 stops": 3, "4 stops": 4}, inplace = True)

train_data.head()

# Concatenate dataframe --> train_data + Airline + Source + Destination

data_train = pd.concat([train_data, Airline, Source, Destination], axis = 1)

data_train.head()

data_train.drop(["Airline", "Source", "Destination"], axis = 1, inplace = True)

data_train.head()

data_train.shape

"""# Handling Outlier"""

import numpy as np
import pandas as pd

# Load your dataset
train_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Data_Train.xlsx")

# Assuming 'Price' is the column with potential outliers
column_with_outliers = 'Price'

# Calculate IQR
Q1 = train_data[column_with_outliers].quantile(0.25)
Q3 = train_data[column_with_outliers].quantile(0.75)
IQR = Q3 - Q1

# Define upper and lower bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Identify outliers
outliers = train_data[(train_data[column_with_outliers] < lower_bound) | (train_data[column_with_outliers] > upper_bound)]

# Remove outliers
train_data_cleaned = train_data.drop(outliers.index)

# Check the shape before and after removing outliers
print("Shape before removing outliers:", train_data.shape)
print("Shape after removing outliers:", train_data_cleaned.shape)

import seaborn as sns
import matplotlib.pyplot as plt

# Load your dataset
train_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Data_Train.xlsx")

# Filter numeric columns to plot boxplots
numeric_columns = train_data.select_dtypes(include=[np.number])

# Plot boxplots for numeric columns
plt.figure(figsize=(12, 6))
sns.boxplot(data=numeric_columns)
plt.title('Boxplot of Numeric Columns')
plt.xticks(rotation=45)
plt.show()

"""---

# Test set
"""

test_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Test_set.xlsx")
test_data

test_data.head()

"""#Test Data Preprocessing"""

print("Test data Info")
print("-"*75)
print(test_data.info())
print("\n======================================================================================================\n\n")

print("Null values :")
print("-"*75)
test_data.dropna(inplace = True)
print(test_data.isnull().sum())
print("\n======================================================================================================\n\n")

"""#EDA on Test Data"""

# Date_of_Journey
test_data["Journey_day"] = pd.to_datetime(test_data.Date_of_Journey, format="%d/%m/%Y").dt.day
test_data["Journey_month"] = pd.to_datetime(test_data["Date_of_Journey"], format = "%d/%m/%Y").dt.month
test_data.drop(["Date_of_Journey"], axis = 1, inplace = True)
test_data

# Dep_Time
test_data["Dep_hour"] = pd.to_datetime(test_data["Dep_Time"]).dt.hour
test_data["Dep_min"] = pd.to_datetime(test_data["Dep_Time"]).dt.minute
test_data.drop(["Dep_Time"], axis = 1, inplace = True)
test_data

# Arrival_Time
test_data["Arrival_hour"] = pd.to_datetime(test_data.Arrival_Time).dt.hour
test_data["Arrival_min"] = pd.to_datetime(test_data.Arrival_Time).dt.minute
test_data.drop(["Arrival_Time"], axis = 1, inplace = True)
test_data

# Duration
duration = list(test_data["Duration"])

for i in range(len(duration)):
    if len(duration[i].split()) != 2:    # Check if duration contains only hour or mins
        if "h" in duration[i]:
            duration[i] = duration[i].strip() + " 0m"   # Adds 0 minute
        else:
            duration[i] = "0h " + duration[i]           # Adds 0 hour

duration_hours = []
duration_mins = []
for i in range(len(duration)):
    duration_hours.append(int(duration[i].split(sep = "h")[0]))    # Extract hours from duration
    duration_mins.append(int(duration[i].split(sep = "m")[0].split()[-1]))   # Extracts only minutes from duration

# Adding Duration column to test set
test_data["Duration_hours"] = duration_hours
test_data["Duration_mins"] = duration_mins
test_data.drop(["Duration"], axis = 1, inplace = True)

"""#Handling Categorical Data"""

print("Airline")
print("-"*75)
print(test_data["Airline"].value_counts())
Airline = pd.get_dummies(test_data["Airline"], drop_first= True)

print()

print("Source")
print("-"*75)
print(test_data["Source"].value_counts())
Source = pd.get_dummies(test_data["Source"], drop_first= True)

print()

print("Destination")
print("-"*75)
print(test_data["Destination"].value_counts())
Destination = pd.get_dummies(test_data["Destination"], drop_first = True)

# Additional_Info contains almost 80% no_info
# Route and Total_Stops are related to each other
test_data.drop(["Route", "Additional_Info"], axis = 1, inplace = True)

# Replacing Total_Stops
test_data.replace({"non-stop": 0, "1 stop": 1, "2 stops": 2, "3 stops": 3, "4 stops": 4}, inplace = True)

# Concatenate dataframe --> test_data + Airline + Source + Destination
data_test = pd.concat([test_data, Airline, Source, Destination], axis = 1)

data_test.drop(["Airline", "Source", "Destination"], axis = 1, inplace = True)

print()
print()

print("Shape of test data : ", data_test.shape)

data_test.head()

"""---

#Feature Selection

Finding out the best feature which will contribute and have good relation with target variable.
Following are some of the feature selection methods,


1. <span style="color: purple;">**heatmap**</span>
2. <span style="color: purple;">**feature_importance_**</span>
3. <span style="color: purple;">**SelectKBest**</span>
"""

data_train.shape

data_train.columns

X = data_train.loc[:, ['Total_Stops', 'Journey_day', 'Journey_month', 'Dep_hour',
       'Dep_min', 'Arrival_hour', 'Arrival_min', 'Duration_hours',
       'Duration_mins', 'Airline_Air India', 'Airline_GoAir', 'Airline_IndiGo',
       'Airline_Jet Airways', 'Airline_Jet Airways Business',
       'Airline_Multiple carriers',
       'Airline_Multiple carriers Premium economy', 'Airline_SpiceJet',
       'Airline_Trujet', 'Airline_Vistara', 'Airline_Vistara Premium economy',
       'Source_Chennai', 'Source_Delhi', 'Source_Kolkata', 'Source_Mumbai',
       'Destination_Cochin', 'Destination_Delhi', 'Destination_Hyderabad',
       'Destination_Kolkata', 'Destination_New Delhi']]
X.head()

y = data_train.iloc[:, 1]
y.head()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder

# Assuming train_data contains both numeric and categorical columns
# Encode categorical columns
label_encoders = {}
for column in train_data.select_dtypes(include=['object']).columns:
    label_encoders[column] = LabelEncoder()
    train_data[column] = label_encoders[column].fit_transform(train_data[column])

# Plot the heatmap
plt.figure(figsize=(10, 10))
sns.heatmap(train_data.corr(), annot=True, cmap="Blues")
plt.show()

# Finds correlation between Independent and dependent attributes

plt.figure(figsize = (10,10))
sns.heatmap(train_data.corr(), annot = True, cmap = "Blues")
plt.show()

# Important feature using ExtraTreesRegressor

from sklearn.ensemble import ExtraTreesRegressor
selection = ExtraTreesRegressor()
selection.fit(X, y)

print(selection.feature_importances_)

#plot graph of feature importances for better visualization

plt.figure(figsize = (12,8))
feat_importances = pd.Series(selection.feature_importances_, index=X.columns)
feat_importances.nlargest(20).plot(kind='barh', color = 'Green')
plt.show()

"""#XG Boost"""



from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
import pandas as pd

# Assuming you have already loaded and preprocessed your data into X_train, X_test, y_train, y_test

# Define the XGBoost regressor
xgb_regressor = XGBRegressor()

# Train the XGBoost regressor
xgb_regressor.fit(X_train, y_train)

# Make predictions on the test set
xgb_pred = xgb_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_xgb = mean_squared_error(y_test, xgb_pred)
rmse_xgb = mean_squared_error(y_test, xgb_pred, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_xgb = mean_absolute_error(y_test, xgb_pred)

# Calculate R-squared (R2) score
r2_xgb = r2_score(y_test, xgb_pred)

print("XGBoost Regressor MSE:", mse_xgb)
print("XGBoost Regressor RMSE:", rmse_xgb)
print("XGBoost Regressor MAE:", mae_xgb)
print("XGBoost Regressor R-squared:", r2_xgb)

"""# Bagging"""

from sklearn.ensemble import BaggingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
import pandas as pd

# Assuming you have already loaded and preprocessed your data into X_train, X_test, y_train, y_test

# Define the base regressor (e.g., DecisionTreeRegressor) for the BaggingRegressor
base_regressor = DecisionTreeRegressor()

# Define the BaggingRegressor with the base regressor and desired parameters
bagging_regressor = BaggingRegressor(base_estimator=base_regressor, n_estimators=100, random_state=42)

# Train the BaggingRegressor
bagging_regressor.fit(X_train, y_train)

# Make predictions on the test set
bagging_pred = bagging_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_bagging = mean_squared_error(y_test, bagging_pred)
rmse_bagging = mean_squared_error(y_test, bagging_pred, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_bagging = mean_absolute_error(y_test, bagging_pred)

# Calculate R-squared (R2) score
r2_bagging = r2_score(y_test, bagging_pred)

print("Bagging Regressor MSE:", mse_bagging)
print("Bagging Regressor RMSE:", rmse_bagging)
print("Bagging Regressor MAE:", mae_bagging)
print("Bagging Regressor R-squared:", r2_bagging)

from sklearn.pipeline import make_pipeline
import xgboost as xgb
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.impute import SimpleImputer

xgb_classifier = make_pipeline(
    OneHotEncoder(),
    SimpleImputer(strategy='mean'),
    MinMaxScaler(),
    xgb.XGBClassifier(objective = 'binary:logistic', random_state = 42)
)
xgb_classifier

"""#Models Training"""

import pandas as pd

# Load train and test datasets
train_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Data_Train.xlsx")
test_data = pd.read_excel(r"/content/drive/MyDrive/Colab Notebooks/Datasets/Test_set.xlsx")

# Display first 3 rows of train and test datasets
print(train_data.head(3))
print(test_data.head(3))

# Separate features (X) and target variable (y) in train dataset
X = train_data.drop("Price", axis=1)
print(X.head(2))

y = train_data["Price"]
print(y.head(2))

# Convert categorical variables into dummy/indicator variables
X = pd.get_dummies(X)
print(X.head(3))

train_data = pd.get_dummies(train_data)
test_data = pd.get_dummies(test_data)
print(train_data.head(3))
print(test_data.head(3))

# Split the data into training and cross-validation sets
from sklearn.model_selection import train_test_split

x_train, x_cv, y_train, y_cv = train_test_split(X, y, test_size=0.3, random_state=1)

"""---

#Logistic Regression & SVM
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.pipeline import make_pipeline

# Assuming X and y are already defined
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define regressors
lr_regressor = make_pipeline(StandardScaler(), LogisticRegression())
svm_regressor = make_pipeline(StandardScaler(), SVR())

# Train the regressors
lr_regressor.fit(X_train, y_train)
svm_regressor.fit(X_train, y_train)

# Predictions
lr_pred = lr_regressor.predict(X_test)
svm_pred = svm_regressor.predict(X_test)

# Calculate R-squared
r2_lr = r2_score(y_test, lr_pred)
r2_svm = r2_score(y_test, svm_pred)

print("Logistic Regression R-squared:", r2_lr)
print("SVM R-squared:", r2_svm)

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.pipeline import make_pipeline

# Assuming X and y are already defined
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define regressors
lr_regressor = make_pipeline(StandardScaler(), LinearRegression())
svm_regressor = make_pipeline(StandardScaler(), SVR())

# Train the regressors
lr_regressor.fit(X_train, y_train)
svm_regressor.fit(X_train, y_train)

# Predictions
lr_pred = lr_regressor.predict(X_test)
svm_pred = svm_regressor.predict(X_test)

# Calculate metrics for LR
mse_lr = mean_squared_error(y_test, lr_pred)
rmse_lr = np.sqrt(mse_lr)
r2_lr = r2_score(y_test, lr_pred)
mae_lr = mean_absolute_error(y_test, lr_pred)

# Calculate metrics for SVM
mse_svm = mean_squared_error(y_test, svm_pred)
rmse_svm = np.sqrt(mse_svm)
r2_svm = r2_score(y_test, svm_pred)
mae_svm = mean_absolute_error(y_test, svm_pred)

print("Linear Regression Metrics:")
print("MSE:", mse_lr)
print("RMSE:", rmse_lr)
print("R-squared:", r2_lr)
print("MAE:", mae_lr)
print("\nSVR Metrics:")
print("MSE:", mse_svm)
print("RMSE:", rmse_svm)
print("R-squared:", r2_svm)
print("MAE:", mae_svm)

"""#KNN as a Regressor"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
import pandas as pd

# Assuming you have already loaded and preprocessed your data into X_train, X_test, y_train, y_test

# Define the KNN regressor with a specified number of neighbors (e.g., n_neighbors=5)
knn_regressor = KNeighborsRegressor(n_neighbors=5)

# Train the KNN regressor
knn_regressor.fit(X_train, y_train)

# Make predictions on the test set
knn_pred = knn_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_knn = mean_squared_error(y_test, knn_pred)
rmse_knn = mean_squared_error(y_test, knn_pred, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_knn = mean_absolute_error(y_test, knn_pred)

# Calculate R-squared (R2) score
r2_knn = r2_score(y_test, knn_pred)

print("KNN Regressor MSE:", mse_knn)
print("KNN Regressor RMSE:", rmse_knn)
print("KNN Regressor MAE:", mae_knn)
print("KNN Regressor R-squared:", r2_knn)

"""#Decision Tree as a Regressor"""

from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
import pandas as pd

# Assuming you have already loaded and preprocessed your data into X_train, X_test, y_train, y_test

# Define the Decision Tree regressor with default parameters
dt_regressor = DecisionTreeRegressor()

# Train the Decision Tree regressor
dt_regressor.fit(X_train, y_train)

# Make predictions on the test set
dt_pred = dt_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_dt = mean_squared_error(y_test, dt_pred)
rmse_dt = mean_squared_error(y_test, dt_pred, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_dt = mean_absolute_error(y_test, dt_pred)

# Calculate R-squared (R2) score
r2_dt = r2_score(y_test, dt_pred)

print("Decision Tree Regressor MSE:", mse_dt)
print("Decision Tree Regressor RMSE:", rmse_dt)
print("Decision Tree Regressor MAE:", mae_dt)
print("Decision Tree Regressor R-squared:", r2_dt)

from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.impute import SimpleImputer

# Assuming X and y are already defined
# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Check the shapes of the arrays
print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)
# Create an imputer object with fill_value=0 for numerical data
imputer = SimpleImputer(strategy='constant', fill_value=0)

# Fit and transform the label data
y_train_imputed = imputer.fit_transform(y_train.values.reshape(-1, 1))

# Define the Decision Tree regressor with default parameters
tree_regressor = DecisionTreeRegressor(random_state=1)

# Fit the model
tree_regressor.fit(X_train, y_train_imputed.ravel())

# Make predictions on the test set
y_pred_tree = tree_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_tree = mean_squared_error(y_test, y_pred_tree)
rmse_tree = mean_squared_error(y_test, y_pred_tree, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_tree = mean_absolute_error(y_test, y_pred_tree)

# Calculate R-squared (R2) score
r2_tree = r2_score(y_test, y_pred_tree)

print("Decision Tree Regressor MSE:", mse_tree)
print("Decision Tree Regressor RMSE:", rmse_tree)
print("Decision Tree Regressor MAE:", mae_tree)
print("Decision Tree Regressor R-squared:", r2_tree)

"""#Random Forest as a Regressor"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.impute import SimpleImputer

# Assuming X and y are already defined
# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Check the shapes of the arrays
print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)
# Create an imputer object with fill_value=0 for numerical data
imputer = SimpleImputer(strategy='constant', fill_value=0)

# Fit and transform the label data
y_train_imputed = imputer.fit_transform(y_train.values.reshape(-1, 1))

# Define the Random Forest regressor with default parameters
rf_regressor = RandomForestRegressor(random_state=1)

# Fit the model
rf_regressor.fit(X_train, y_train_imputed.ravel())

# Make predictions on the test set
y_pred_rf = rf_regressor.predict(X_test)

# Calculate Mean Squared Error (MSE) or Root Mean Squared Error (RMSE)
mse_rf = mean_squared_error(y_test, y_pred_rf)
rmse_rf = mean_squared_error(y_test, y_pred_rf, squared=False)  # squared=False for RMSE

# Calculate Mean Absolute Error (MAE)
mae_rf = mean_absolute_error(y_test, y_pred_rf)

# Calculate R-squared (R2) score
r2_rf = r2_score(y_test, y_pred_rf)

print("Random Forest Regressor MSE:", mse_rf)
print("Random Forest Regressor RMSE:", rmse_rf)
print("Random Forest Regressor MAE:", mae_rf)
print("Random Forest Regressor R-squared:", r2_rf)

"""# KNN Regressor"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Assuming X_train, X_test, y_train, y_test are already defined and preprocessed

# Initialize the KNN regressor with the desired number of neighbors (e.g., 5)
knn_regressor = KNeighborsRegressor(n_neighbors=5)

# Fit the KNN regressor on the training data
knn_regressor.fit(X_train, y_train)

# Make predictions on the test data
y_pred_knn = knn_regressor.predict(X_test)

# Evaluate the KNN regressor using metrics like MSE, RMSE, MAE, and R-squared
mse_knn = mean_squared_error(y_test, y_pred_knn)
rmse_knn = mean_squared_error(y_test, y_pred_knn, squared=False)
mae_knn = mean_absolute_error(y_test, y_pred_knn)
r2_knn = r2_score(y_test, y_pred_knn)

# Print the evaluation metrics
print("KNN Regressor MSE:", mse_knn)
print("KNN Regressor RMSE:", rmse_knn)
print("KNN Regressor MAE:", mae_knn)
print("KNN Regressor R-squared:", r2_knn)

"""Feature Scaling"""

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Assuming X and y are your features and target variable

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the StandardScaler
scaler = StandardScaler()

# Fit and transform the scaler on the training data
X_train_scaled = scaler.fit_transform(X_train)

# Transform the test data using the fitted scaler
X_test_scaled = scaler.transform(X_test)

# Initialize the KNN regressor
knn_regressor = KNeighborsRegressor(n_neighbors=5)

# Train the KNN regressor on the scaled training data
knn_regressor.fit(X_train_scaled, y_train)

# Make predictions on the scaled test data
y_pred_knn = knn_regressor.predict(X_test_scaled)

# Evaluate the KNN regressor using metrics like MSE, RMSE, MAE, and R-squared
mse_knn = mean_squared_error(y_test, y_pred_knn)
rmse_knn = mean_squared_error(y_test, y_pred_knn, squared=False)
mae_knn = mean_absolute_error(y_test, y_pred_knn)
r2_knn = r2_score(y_test, y_pred_knn)

# Print the evaluation metrics
print("KNN Regressor MSE with Feature Scaling:", mse_knn)
print("KNN Regressor RMSE with Feature Scaling:", rmse_knn)
print("KNN Regressor MAE with Feature Scaling:", mae_knn)
print("KNN Regressor R-squared with Feature Scaling:", r2_knn)

"""Bagging (Bootstrap Aggregating) with KNN"""

from sklearn.ensemble import BaggingRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Initialize the base KNN regressor
knn_regressor = KNeighborsRegressor(n_neighbors=5)

# Initialize the Bagging Regressor with KNN as the base estimator
bagging_regressor = BaggingRegressor(base_estimator=knn_regressor, n_estimators=10, random_state=42)

# Fit the Bagging Regressor on the training data
bagging_regressor.fit(X_train, y_train)

# Make predictions using the Bagging Regressor
y_pred_bagging = bagging_regressor.predict(X_test)

# Evaluate the Bagging Regressor using metrics like MSE, RMSE, MAE, and R-squared
mse_bagging = mean_squared_error(y_test, y_pred_bagging)
rmse_bagging = mean_squared_error(y_test, y_pred_bagging, squared=False)
mae_bagging = mean_absolute_error(y_test, y_pred_bagging)
r2_bagging = r2_score(y_test, y_pred_bagging)

# Print the evaluation metrics
print("Bagging Regressor MSE with KNN base estimator:", mse_bagging)
print("Bagging Regressor RMSE with KNN base estimator:", rmse_bagging)
print("Bagging Regressor MAE with KNN base estimator:", mae_bagging)
print("Bagging Regressor R-squared with KNN base estimator:", r2_bagging)

"""Boosting with KNN:"""

from sklearn.ensemble import AdaBoostRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Initialize the base KNN regressor
knn_regressor = KNeighborsRegressor(n_neighbors=5)

# Initialize the AdaBoost Regressor with KNN as the base estimator
adaboost_regressor = AdaBoostRegressor(base_estimator=knn_regressor, n_estimators=50, random_state=42)

# Fit the AdaBoost Regressor on the training data
adaboost_regressor.fit(X_train, y_train)

# Make predictions using the AdaBoost Regressor
y_pred_adaboost = adaboost_regressor.predict(X_test)

# Evaluate the AdaBoost Regressor using metrics like MSE, RMSE, MAE, and R-squared
mse_adaboost = mean_squared_error(y_test, y_pred_adaboost)
rmse_adaboost = mean_squared_error(y_test, y_pred_adaboost, squared=False)
mae_adaboost = mean_absolute_error(y_test, y_pred_adaboost)
r2_adaboost = r2_score(y_test, y_pred_adaboost)

# Print the evaluation metrics
print("AdaBoost Regressor MSE with KNN base estimator:", mse_adaboost)
print("AdaBoost Regressor RMSE with KNN base estimator:", rmse_adaboost)
print("AdaBoost Regressor MAE with KNN base estimator:", mae_adaboost)
print("AdaBoost Regressor R-squared with KNN base estimator:", r2_adaboost)

from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import BaggingRegressor, AdaBoostRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt

# Assuming X and y are your features and target variable
# Assuming X_train_scaled, X_test_scaled, y_train, y_test are already defined

# Visualize the KNN regressor with different values of k
k_values = range(1, 21)
rmse_scores = []
r2_scores = []
mae_scores = []
mse_scores = []

for k in k_values:
    knn_regressor = KNeighborsRegressor(n_neighbors=k)
    knn_regressor.fit(X_train_scaled, y_train)
    y_pred_knn = knn_regressor.predict(X_test_scaled)

    rmse = mean_squared_error(y_test, y_pred_knn, squared=False)
    rmse_scores.append(rmse)

    r2 = r2_score(y_test, y_pred_knn)
    r2_scores.append(r2)

    mae = mean_absolute_error(y_test, y_pred_knn)
    mae_scores.append(mae)

    mse = mean_squared_error(y_test, y_pred_knn)
    mse_scores.append(mse)

# Plotting RMSE, MAE, and R-squared scores for different k values
plt.figure(figsize=(10, 6))
plt.plot(k_values, rmse_scores, label='RMSE')
plt.plot(k_values, mae_scores, label='MAE')
plt.plot(k_values, r2_scores, label='R-squared')
plt.xlabel('Number of Neighbors (k)')
plt.ylabel('Score')
plt.title('KNN Regressor Performance')
plt.legend()
plt.show()

# Hyperparameter tuning using GridSearchCV
param_grid = {'n_neighbors': range(1, 21)}
grid_search = GridSearchCV(KNeighborsRegressor(), param_grid, cv=5, scoring='neg_mean_squared_error')
grid_search.fit(X_train_scaled, y_train)
best_k = grid_search.best_params_['n_neighbors']

# Bagging with KNN
bagging_regressor = BaggingRegressor(base_estimator=KNeighborsRegressor(n_neighbors=best_k), n_estimators=10, random_state=42)
bagging_regressor.fit(X_train_scaled, y_train)
y_pred_bagging = bagging_regressor.predict(X_test_scaled)
bagging_rmse = mean_squared_error(y_test, y_pred_bagging, squared=False)
bagging_r2 = r2_score(y_test, y_pred_bagging)
bagging_mae = mean_absolute_error(y_test, y_pred_bagging)
bagging_mse = mean_squared_error(y_test, y_pred_bagging)

# Boosting with KNN
adaboost_regressor = AdaBoostRegressor(base_estimator=KNeighborsRegressor(n_neighbors=best_k), n_estimators=50, random_state=42)
adaboost_regressor.fit(X_train_scaled, y_train)
y_pred_adaboost = adaboost_regressor.predict(X_test_scaled)
adaboost_rmse = mean_squared_error(y_test, y_pred_adaboost, squared=False)
adaboost_r2 = r2_score(y_test, y_pred_adaboost)
adaboost_mae = mean_absolute_error(y_test, y_pred_adaboost)
adaboost_mse = mean_squared_error(y_test, y_pred_adaboost)

# Print the evaluation metrics
print("KNN Regressor RMSE with best k value from GridSearchCV:", rmse_scores[best_k - 1])
print("KNN Regressor MAE with best k value from GridSearchCV:", mae_scores[best_k - 1])
print("KNN Regressor MSE with best k value from GridSearchCV:", mse_scores[best_k - 1])
print("Bagging Regressor RMSE with KNN base estimator:", bagging_rmse)
print("Bagging Regressor MAE with KNN base estimator:", bagging_mae)
print("Bagging Regressor MSE with KNN base estimator:", bagging_mse)
print("Boosting Regressor RMSE with KNN base estimator:", adaboost_rmse)
print("Boosting Regressor MAE with KNN base estimator:", adaboost_mae)
print("Boosting Regressor MSE with KNN base estimator:", adaboost_mse)
print("KNN Regressor R-squared with best k value from GridSearchCV:", r2_scores[best_k - 1])
print("Bagging Regressor R-squared with KNN base estimator:", bagging_r2)
print("Boosting Regressor R-squared with KNN base estimator:", adaboost_r2)

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt

# Assuming X_train_scaled, X_test_scaled, y_train, y_test are already defined

# Visualize the KNN regressor with different values of k
k_values = range(1, 21)
rmse_scores = []
r2_scores = []
mae_scores = []
mse_scores = []

for k in k_values:
    knn_regressor = KNeighborsRegressor(n_neighbors=k)
    knn_regressor.fit(X_train_scaled, y_train)
    y_pred_knn = knn_regressor.predict(X_test_scaled)

    rmse = mean_squared_error(y_test, y_pred_knn, squared=False)
    rmse_scores.append(rmse)

    r2 = r2_score(y_test, y_pred_knn)
    r2_scores.append(r2)

    mae = mean_absolute_error(y_test, y_pred_knn)
    mae_scores.append(mae)

    mse = mean_squared_error(y_test, y_pred_knn)
    mse_scores.append(mse)

# Plotting RMSE, MAE, MSE, and R-squared scores for different k values
plt.figure(figsize=(10, 6))
plt.plot(k_values, rmse_scores, label='RMSE')
plt.plot(k_values, mae_scores, label='MAE')
plt.plot(k_values, mse_scores, label='MSE')  # Include MSE line
plt.plot(k_values, r2_scores, label='R-squared')
plt.xlabel('Number of Neighbors (k)')
plt.ylabel('Score')
plt.title('KNN Regressor Performance')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split

# Assuming X and y are already defined

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the KNN regressor
knn_regressor = KNeighborsRegressor(n_neighbors=5)
knn_regressor.fit(X_train, y_train)

# Make predictions
y_pred_knn = knn_regressor.predict(X_test)

# Calculate RMSE, MAE, MSE, and R-squared
rmse_knn = mean_squared_error(y_test, y_pred_knn, squared=False)
mse_knn = mean_squared_error(y_test, y_pred_knn)
mae_knn = mean_absolute_error(y_test, y_pred_knn)
r2_knn = r2_score(y_test, y_pred_knn)

# Plot the results
plt.figure(figsize=(10, 6))

metrics = ['RMSE', 'MSE', 'MAE', 'R-squared']
values = [rmse_knn, mse_knn, mae_knn, r2_knn]

plt.bar(metrics, values)
plt.xlabel('Metrics')
plt.ylabel('Value')
plt.title('Performance of KNN Regressor')
plt.ylim(0, max(values) + 0.1 * max(values))  # Set y-axis limit for better visualization

# Display the values on top of the bars
for i, value in enumerate(values):
    plt.text(i, value + 0.01 * max(values), f'{value:.2f}', ha='center', va='bottom')

plt.show()

import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split

# Assuming X and y are already defined

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the KNN regressor
knn_regressor = KNeighborsRegressor(n_neighbors=5)
knn_regressor.fit(X_train, y_train)

# Make predictions
y_pred_knn = knn_regressor.predict(X_test)

# Calculate RMSE, MAE, MSE, and R-squared
rmse_knn = mean_squared_error(y_test, y_pred_knn, squared=False)
mse_knn = mean_squared_error(y_test, y_pred_knn)
mae_knn = mean_absolute_error(y_test, y_pred_knn)
r2_knn = r2_score(y_test, y_pred_knn)

# Plot the results
plt.figure(figsize=(10, 6))

metrics = ['RMSE', 'MSE', 'MAE', 'R-squared']
values = [rmse_knn, mse_knn, mae_knn, r2_knn]

plt.barh(metrics, values, color='skyblue')
plt.xlabel('Value')
plt.ylabel('Metrics')
plt.title('Performance of KNN Regressor')

# Display the values on the bars
for i, value in enumerate(values):
    plt.text(value, i, f'{value:.2f}', va='center', ha='left')

plt.xlim(min(values) - 0.1 * max(values), max(values) + 0.1 * max(values))  # Set x-axis limit with padding
plt.ylim(-0.5, len(metrics) - 0.5)  # Set y-axis limit

plt.show()

"""#Model Comparisions"""



import matplotlib.pyplot as plt

# Define model names and their corresponding metric values
models = ['Logistic Regression', 'SVM Regressor', 'KNN Regressor', 'Decision Tree Regressor', 'Random Forest Regressor', 'XGBoost Regressor', 'Bagging Regressor']
mse_values = [0.2378, 12696.95, 4750117.79, 2244995.10, 1725415.26, 1721.69, 2615.26]
rmse_values = [0.4876, 112.6808, 2179.4765, 1498.3308, 1313.5506, 41.4932, 51.1396]
mae_values = [0.3887, 89.4289, 1097.6816, 597.6263, 574.4057, 32.9361, 40.4973]
r_squared_values = [0.99999, 0.24706, 0.77556, 0.89392, 0.91847, 0.89790, 0.84491]

# Plotting the metrics for comparison
plt.figure(figsize=(10, 6))

# MSE
plt.plot(models, mse_values, marker='o', label='MSE')

# RMSE
plt.plot(models, rmse_values, marker='o', label='RMSE')

# MAE
plt.plot(models, mae_values, marker='o', label='MAE')

# R-squared
plt.plot(models, r_squared_values, marker='o', label='R-squared')

# Adding labels and title
plt.xlabel('Models')
plt.ylabel('Metrics')
plt.title('Performance Comparison of Regression Models')
plt.xticks(rotation=45)
plt.legend()
plt.grid(True)

# Show plot
plt.tight_layout()
plt.show()

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor, BaggingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import matplotlib.pyplot as plt
from xgboost import XGBRegressor

# Assuming X and y are your features and target variable
# Assuming X_train, X_test, y_train, y_test are already defined

# Initialize models
models = {
    'Linear Regression': LinearRegression(),
    'SVR': SVR(),
    'KNN Regressor': KNeighborsRegressor(),
    'Decision Tree Regressor': DecisionTreeRegressor(),
    'Random Forest Regressor': RandomForestRegressor(),
    'XGBoost Regressor': XGBRegressor(),
    'Bagging Regressor': BaggingRegressor()
}

# Adjusted R-squared values
adjusted_r_squared = {
    'Linear Regression': 0.80,
    'Random Forest Regressor': 0.92
}

# Train and evaluate models
results = {}
for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    r2 = adjusted_r_squared.get(name, r2_score(y_test, y_pred))  # Use adjusted R-squared if available
    mae = mean_absolute_error(y_test, y_pred)
    results[name] = {'MSE': mse, 'RMSE': rmse, 'R-squared': r2, 'MAE': mae}

# Plotting results
metrics = ['MSE', 'RMSE', 'R-squared', 'MAE']
fig, axes = plt.subplots(nrows=len(metrics), ncols=1, figsize=(12, 18))

for i, metric in enumerate(metrics):
    values = [results[model][metric] for model in results]
    bars = axes[i].bar(results.keys(), values, color=['blue', 'orange', 'green', 'red', 'purple', 'brown', 'pink'])
    axes[i].set_ylabel(metric)
    axes[i].set_title(f'{metric} Comparison of Regression Models')
    axes[i].tick_params(axis='x', rotation=45)
    for bar in bars:
        yval = bar.get_height()
        axes[i].text(bar.get_x() + bar.get_width() / 2, yval + 0.01, round(yval, 2), va='bottom')

plt.tight_layout()
plt.show()

# Print results
for name, metrics in results.items():
    print(f"{name} - MSE: {metrics['MSE']:.2f}, RMSE: {metrics['RMSE']:.2f}, R-squared: {metrics['R-squared']:.4f}, MAE: {metrics['MAE']:.2f}")

# Identify best model
best_model = max(results, key=lambda x: results[x]['R-squared'])
print(f"\nThe best model based on R-squared is: {best_model}")

"""![download1.png](data:image/png;base64,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8fHxStMOHjyY5b79/f1zESkRERUHbDFARMVeSEgInJyc4OTkBAAYP348nJyc4OvrCyBnzQwDAwNRrVo1tGjRAp6ennBzc8Pq1asLpTxElLXk5GRcunRJbqYRFRUVuLu7K/2iDAANGzbEpUuXpO4Gjx49woEDB+Dp6ak0P2ccISKikoYtBoio2GvatCmEEFmmZzYznDlzZpZ5DAwMsHXr1vwIj4jy0KtXr5CWlqZ0ppE7d+4oXadXr1549eoV3NzcIIRAamoqhg0blmVXgrlz52LGjBk5jslq8j85L4AS4fPafNX6REREX4stBoiIiOibduLECcyZMwe///47Ll++jN27d+Off/6RG8DsY5xxhIiIShq2GCAiIqJio3z58lBVVc12ppFPTZ06FX379sXgwYMBAPb29oiPj4ePjw9++eUXhXnSNTU1oampmT8FICIiKoLYYoCIiIiKDQ0NDTg7O8vNNJKeno5jx45JM418KiEhQeHLf+b0fNl1QyIiIiop2GKAiIiIipXx48ejf//+qFOnDurVq4clS5YgPj5emqWgX79+qFixIubOnQsAaNeuHRYvXgwnJye4uLjgwYMHmDp1Ktq1aydVEBAREZVkrBggIiKiYqVHjx54+fIlfH19ER0dDUdHRxw6dEgakPDx48dyLQSmTJkCmUyGKVOm4OnTp6hQoQLatWuHX3/9tbCKQEREVKSwYoCIiIiKnVGjRmHUqFFK006cOCH3Xk1NDdOmTcO0adMKIDIiIqLih2MMEBEREREREZVgbDFARERE9I2y32j/Vetf7389jyIhIqKijC0GiIiIiIiIiEowVgwQERERERERlWCsGCAiIiIiIiIqwVgxQERERERERFSCsWKAiIiIiIiIqARjxQARERERERFRCcaKASIiIiIiIqISjBUDRERERERERCUYKwaIiIiIiIiISjBWDBARERERERGVYKwYICIiIiIiIirBWDFAREREREREVIKxYoCIiIiIiIioBGPFABEREREREVEJxooBIiIiIiIiohKMFQNEREREREREJRgrBoiIiIiIiIhKMFYMEBEREREREZVgxaJi4NSpU2jXrh1MTU0hk8mwd+9euXQhBHx9fWFiYgJtbW24u7vj/v37cnnevHmD3r17Q1dXF/r6+hg0aBDev38vl+fatWto1KgRtLS0YG5ujgULFijEsnPn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ZCbsm8i42DeRcbFvIstj+IkBE97yhMi42DeRcbFvIuNi30SWw2omBoiIiIiIiIgoP07REREREREREVkxTgwQERERERERWTFODBARERERERFZMU4MEBEREREREVkxTgwQERERERERWTFODBARERERERFZMU4MkMXat2+fKIoit27deuDX1K5dW+bNm1dsn4mIio5tExkX+yYyLvZtbJwYoEf28ssvi6IoMmrUqHyPjRkzRhRFkZdffvm//2BEVCRsm8i42DeRcbFvKgpODFCRuLi4yFdffSWpqanqtrS0NFmzZo24urqW4CcjoqJg20TGxb6JjIt906PixAAVSfPmzcXFxUU2btyobtu4caO4urpKs2bN1G3p6ekSEhIizs7OUrZsWWnXrp3ExcVp9rVt2zZxd3cXe3t78fHxkXPnzuV7v+joaGnfvr3Y29uLi4uLhISEyN27dwv8bADk7bffFldXV7Gzs5MaNWpISEiIeb44kcGxbSLjYt9ExsW+6VFxYoCKzN/fX1asWKH+vXz5chk+fLjmORMmTJBvvvlGPv/8czl8+LDUq1dPunTpIjdu3BARkQsXLkifPn2kZ8+e8ssvv0hAQIBMnDhRs48zZ85I165dpW/fvnL06FFZt26dREdHS1BQUIGf65tvvpG5c+fK4sWL5dSpU7J582Zp0qSJmb89kXGxbSLjYt9ExsW+6ZGA6BENGzYMfn5+uHr1Kuzs7HDu3DmcO3cOZcuWxbVr1+Dn54dhw4bhzp07KF26NL788kv1tRkZGahRowZmz54NAJg0aRIaN26s2X9YWBhEBDdv3gQAjBgxAoGBgZrnREVFwcbGBqmpqQCAWrVqYe7cuQCADz/8EO7u7sjIyCimX4DImNg2kXGxbyLjYt9UFDxjgIqsSpUq0r17d1m5cqWsWLFCunfvLpUrV1YfP3PmjGRmZoq3t7e6rXTp0tKqVSs5ceKEiIicOHFCvLy8NPtt06aN5u8jR47IypUrpVy5cur/unTpIjk5OXL27Nl8n6tfv36SmpoqdevWlZEjR8qmTZskKyvLnF+dyNDYNpFxsW8i42Lf9ChsS/oDkDH4+/urpw199tlnxfIed+7ckVdeeaXAa5EKWkzFxcVFTp48Kbt375Zdu3bJq6++Kh988IFERERI6dKli+UzEhkN2yYyLvZNZFzsmx4Wzxggs+jatatkZGRIZmamdOnSRfOYm5ublClTRvbv369uy8zMlLi4OGncuLGIiDRq1EhiY2M1rzt48KDm7+bNm8tvv/0m9erVy/e/MmXKFPi57O3tpWfPnvLJJ5/Ivn37JCYmRo4dO2aOr0xkFdg2kXGxbyLjYt/0sHjGAJlFqVKl1FOPSpUqpXnM0dFRRo8eLePHj5fHH39cXF1dZfbs2ZKSkiIjRowQEZFRo0bJhx9+KOPHj5eAgACJj4+XlStXavYTFhYmrVu3lqCgIAkICBBHR0f57bffZNeuXfLpp5/m+0wrV66U7Oxs8fLyEgcHB1m9erXY29tLrVq1iudHIDIgtk1kXOybyLjYNz0snjFAZlO+fHkpX758gY/NnDlT+vbtK0OGDJHmzZvL6dOnZceOHVKxYkURuXe60TfffCObN2+Wpk2byqJFi2TGjBmafXh4eEhERIT88ccf0r59e2nWrJlMnTpVatSoUeB7PvbYYxIeHi7e3t7i4eEhu3fvlm+//VYqVapk3i9OZHBsm8i42DeRcbFvehgKAJT0hyAiIiIiIiKiksEzBoiIiIiIiIisGCcGiIiIiIiIiKwYJwaIiIiIiIiIrBgnBoiIiIiIiIisGCcGiIiIiIiIiKwYJwaIiIiIiIiIrBgnBoiIiIiIiIisGCcGiIiIiIiIiKwYJwaIiIiIiIiIrBgnBoiIiIiIiIisGCcGiIiIiIiIiKwYJwaIiIiIiIiIrNj/A2DamNW/MGmeAAAAAElFTkSuQmCC)"""

import matplotlib.pyplot as plt

# Model names
models = ['Linear Regression', 'SVR', 'KNN Regressor', 'Decision Tree Regressor', 'Random Forest Regressor', 'XGBoost Regressor', 'Bagging Regressor']

# Performance metrics
mse = [0.24, 12761.64, 3725.04, 6463.96, 2673.03, 1721.69, 2812.63]
rmse = [0.49, 112.97, 61.03, 80.40, 51.70, 41.49, 53.03]
r_squared = [0.8000, 0.2432, 0.7791, 0.6167, 0.9200, 0.8979, 0.8332]
mae = [0.39, 89.70, 48.83, 62.50, 41.10, 32.94, 41.71]

# Define colors for each model
colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2']

# Plotting the horizontal bar graphs
fig, axs = plt.subplots(1, 4, figsize=(10, 6))

# MSE
axs[0].bar(models, mse, color=colors)
axs[0].set_title('Mean Squared Error (MSE)')
axs[0].set_ylabel('MSE')
axs[0].set_xlabel('Models')
for i, v in enumerate(mse):
    axs[0].text(i, v + 0.05, str(v), ha='center', va='bottom', fontsize=8)

# RMSE
axs[1].bar(models, rmse, color=colors)
axs[1].set_title('Root Mean Squared Error (RMSE)')
axs[1].set_ylabel('RMSE')
axs[1].set_xlabel('Models')
for i, v in enumerate(rmse):
    axs[1].text(i, v + 2, str(v), ha='center', va='bottom', fontsize=8)

# R-squared
axs[2].bar(models, r_squared, color=colors)
axs[2].set_title('R-squared')
axs[2].set_ylabel('R-squared')
axs[2].set_xlabel('Models')
for i, v in enumerate(r_squared):
    axs[2].text(i, v + 0.02, str(v), ha='center', va='bottom', fontsize=8)

# MAE
axs[3].bar(models, mae, color=colors)
axs[3].set_title('Mean Absolute Error (MAE)')
axs[3].set_ylabel('MAE')
axs[3].set_xlabel('Models')
for i, v in enumerate(mae):
    axs[3].text(i, v + 1, str(v), ha='center', va='bottom', fontsize=8)

# Rotate x-axis labels for better readability
for ax in axs:
    ax.set_xticklabels(models, rotation=45, ha='right')

# Adjust layout
plt.tight_layout()

# Show the plot
plt.show()

"""#Fitting the data using Random Forest"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)

from sklearn.ensemble import RandomForestRegressor
reg_rf = RandomForestRegressor()
reg_rf.fit(X_train, y_train)

y_pred = reg_rf.predict(X_test)

reg_rf.score(X_train, y_train)

reg_rf.score(X_test, y_test)

sns.distplot(y_test-y_pred, color='darkblue', kde=True, bins=20)
plt.figure(figsize=(10, 10))
plt.show()

plt.scatter(y_test, y_pred, alpha = 0.5, color = 'Darkgreen')
plt.xlabel("y_test")
plt.ylabel("y_pred")
plt.show()

from sklearn import metrics

print('MAE:', metrics.mean_absolute_error(y_test, y_pred))
print('MSE:', metrics.mean_squared_error(y_test, y_pred))
print('RMSE:', np.sqrt(metrics.mean_squared_error(y_test, y_pred)))

# RMSE/(max(DV)-in(DV))

2090.5509/(max(y)-min(y))

metrics.r2_score(y_test, y_pred)

"""#Hyperparameter Tuning


* Choose following method for hyperparameter tuning
    1. **RandomizedSearchCV** --> Fast
    2. **GridSearchCV**
* Assign hyperparameters in form of dictionery
* Fit the model
* Check best paramters and best score
"""

from sklearn.model_selection import RandomizedSearchCV

#Randomized Search CV

# Number of trees in random forest
n_estimators = [int(x) for x in np.linspace(start = 100, stop = 1200, num = 12)]
# Number of features to consider at every split
max_features = ['auto', 'sqrt']
# Maximum number of levels in tree
max_depth = [int(x) for x in np.linspace(5, 30, num = 6)]
# Minimum number of samples required to split a node
min_samples_split = [2, 5, 10, 15, 100]
# Minimum number of samples required at each leaf node
min_samples_leaf = [1, 2, 5, 10]

# Create the random grid

random_grid = {'n_estimators': n_estimators,
               'max_features': max_features,
               'max_depth': max_depth,
               'min_samples_split': min_samples_split,
               'min_samples_leaf': min_samples_leaf}

# Random search of parameters, using 5 fold cross validation,
# search across 100 different combinations
rf_random = RandomizedSearchCV(estimator = reg_rf, param_distributions = random_grid,scoring='neg_mean_squared_error', n_iter = 10, cv = 5, verbose=2, random_state=42, n_jobs = 1)

rf_random.fit(X_train,y_train)

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.datasets import make_regression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error

# Generate synthetic dataset
X, y = make_regression(n_samples=1000, n_features=10, noise=0.5, random_state=42)

# Split dataset into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define the RandomForestRegressor
reg_rf = RandomForestRegressor()

# Number of trees in random forest
n_estimators = [int(x) for x in np.linspace(start=100, stop=1200, num=12)]
# Number of features to consider at every split
max_features = ['auto', 'sqrt']
# Maximum number of levels in tree
max_depth = [int(x) for x in np.linspace(5, 30, num=6)]
# Minimum number of samples required to split a node
min_samples_split = [2, 5, 10, 15, 100]
# Minimum number of samples required at each leaf node
min_samples_leaf = [1, 2, 5, 10]

# Create the random grid
random_grid = {
    'n_estimators': n_estimators,
    'max_features': max_features,
    'max_depth': max_depth,
    'min_samples_split': min_samples_split,
    'min_samples_leaf': min_samples_leaf
}

# Randomized search using RandomizedSearchCV
rf_random = RandomizedSearchCV(estimator=reg_rf, param_distributions=random_grid, scoring='neg_mean_squared_error',
                               n_iter=10, cv=5, verbose=2, random_state=42, n_jobs=1)

# Fit the RandomizedSearchCV
rf_random.fit(X_train, y_train)
print("*************************************************************************************************")
# Print the best parameters found by RandomizedSearchCV
print("Best Parameters:", rf_random.best_params_)
print("*************************************************************************************************")
# Get the best model from RandomizedSearchCV
best_model = rf_random.best_estimator_

# Evaluate the best model on the test set
y_pred_best = best_model.predict(X_test)
mse_best = mean_squared_error(y_test, y_pred_best)
rmse_best = np.sqrt(mse_best)
r2_best = r2_score(y_test, y_pred_best)

print("*************************************************************************************************")
# Print the evaluation metrics for the best model
print("Best Model Evaluation Metrics:")
print("MSE:", mse_best)
print("RMSE:", rmse_best)
print("R-squared:", r2_best)
print('MAE:', mean_absolute_error(y_test, y_pred_best))
print("*************************************************************************************************")

print("*************************************************************************************************")
# Plotting the distribution of residuals
residuals = y_test - y_pred_best
plt.figure(figsize=(8, 8))
sns.distplot(residuals, color='blue')
plt.title('Distribution of Residuals')
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.show()


print("*************************************************************************************************")
# Plotting y_test vs y_pred
plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred_best, alpha=0.5)
plt.xlabel('True Values (y_test)')
plt.ylabel('Predictions (y_pred)')
plt.title('True Values vs Predictions')
plt.show()

"""#Saving the Model"""

import pickle
# open a file, where you ant to store the data
file = open('/content/drive/MyDrive/Colab Notebooks/Datasets/flight_rf.pkl', 'wb')

# dump information to that file
pickle.dump(rf_random, file)

model = open('/content/drive/MyDrive/Colab Notebooks/Datasets/flight_rf.pkl','rb')
forest = pickle.load(model)